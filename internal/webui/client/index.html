<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>WebRTC Testing & Troubleshooting Tool</title>
    <link rel="icon" href="data:,">
    <style>
        .container {
            display: flex;
            flex-direction: column;

            margin-left: auto;
            margin-right: auto;
            max-width: 64rem;
        }

        .container__main {
            flex-grow: 1;

            display: flex;
            flex-direction: row;
        }

        .container__left {
            width: 25%;
        }

        .container__middle {
            flex-grow: 1;
            display: flex;
            align-items: end;
            justify-content: center;
        }

        .container__right {
            width: 20%;
        }

        .cards {
            display: flex;

            flex-wrap: wrap;

            margin-left: -8px;
            margin-right: -8px;
        }

        .cards__item {
            flex-basis: 25%;

            padding-left: 8px;
            padding-right: 8px;
        }

        @keyframes append-animate {
            from {
                /*transform: scale(0);*/
                opacity: 0;
            }
            to {
                /*transform: scale(1);*/
                opacity: 1;
            }
        }

        .log {
            align-items: center;
            display: grid;
            grid-template-columns: 15px 1fr 28fr;
            animation: append-animate .3s linear;
        }

        .log div {
            font-size: smaller;
        }

        .log__status, .log__tag {
            align-self: normal;
        }

        .log__status {
            background-color: rgb(66, 153, 225);

            border-radius: 9999px;

            height: 8px;
            width: 8px;
        }

        .log__tag {
            color: rgba(0, 0, 0, .45);
            text-transform: uppercase;
        }

        .log__client {
            background-color: #e18a42;
        }

        .log__content {
            flex: 1;
        }

        .log.break {
            margin: 0.3em 0;
        }

        .options {
            align-items: center;
            display: flex;

            justify-content: space-between;
            border-bottom: 1px solid rgba(0, 0, 0, 0.3);

            margin: 0;
            padding: 8px 0;
        }

        .options dd {
            margin: 0;
        }

        div#inboundDataChannelMessages, div#iceConnectionStates {
            height: 100px;
            overflow: auto;
            font-size: 80%;
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        WebRTC Testing & Troubleshooting Tool
    </header>
    <main class="container__main">
        <div class="container__left">...</div>

        <div class="container__middle">

            <div class="controls">
                <button id="controls__button">Start</button>
            </div>

        </div>

        <div class="container__right">
            <h4>Options </h4>
            <dl class="options">
                <dt>Flip the offer and the answer sides</dt>
                <dd><input type="checkbox"/></dd>
            </dl>
            <dl class="options">
                <dt>Disable default Interceptors</dt>
                <dd><input type="checkbox"/></dd>
            </dl>
            <dl class="options">
                <dt>Set DTLS role</dt>
                <dd><input type="text"/></dd>
            </dl>
            <dl class="options">
                <dt>Use ICE Lite</dt>
                <dd><input type="checkbox"/></dd>
            </dl>
            <dl class="options">
                <dt>Set a single port</dt>
                <dd><input type="text"/></dd>
            </dl>
            <dl class="options">
                <dt>Set NAT-IP-MAP</dt>
                <dd><input type="text"/></dd>
            </dl>
        </div>
    </main>
    <footer>
        <div class="logging">
            <h3>Log</h3>
            <div id="logMessages"></div>
        </div>
    </footer>
</div>
</body>
<script>
    const gui = (() => {
        const dest = document.getElementById('logMessages')

        const log = (message, server = true, tag) => {
            const el = document.createElement('div')
            el.classList.add('log')
            if (message) {
                el.innerHTML = `
                        <div class="log__status${server ? ' log__server' : ' log__client'}"></div>
                        ${tag ? `<div class="log__tag">${tag}</div>` : ''}
                        <div class="log__content">${message}</div>
                        `
            } else {
                el.classList.add('break')
            }
            dest.appendChild(el)
        }

        return {
            log,
        }
    })()

    const socket = ({url}) => (() => {
        let _socket, finish, handlers = [];
        const log = (m) => gui.log(m, false, 'WS');

        const connect = () => new Promise(function (resolve, reject) {
            log(`connect to ${url}`)
            _socket = new WebSocket(url)
            _socket.onmessage = e => {
                const msg = JSON.parse(e.data)
                if (!msg) {
                    log('error: failed to parse msg')
                }
                handlers.forEach(h => h(msg))
            }
            _socket.onopen = e => {
                log('socket opened')
                resolve(e)
            }
            _socket.onclose = _ => {
                finish()
                log('socket closed')
            }
            _socket.onerror = e => {
                log(`socket fail${e.message ? `: ${e.message}` : ''}`)
                reject(e)
            }
        })

        const disconnect = () => new Promise(function (resolve) {
            if (!_socket) return;
            finish = resolve
            handlers = []
            _socket.close()
            _socket = null
        })

        return {
            connect,
            disconnect,
            send: (data) => _socket.send(data),
            set onmessage(handler) {
                handlers.push(handler)
            },
        }
    })();

    const webrtc = ({transport}) => (() => {
        let pc
        const log = {
            ice: (m, remote = false) => gui.log(m, remote, 'ICE'),
            rtc: (m, remote = false) => gui.log(m, remote, 'RTC'),
        }

        const signal = {
            send: (dat) => transport.send(JSON.stringify(dat)),
            connect: async _ => transport.connect(),
            disconnect: async _ => transport.disconnect(),
            set wire(handler) {
                transport.onmessage = handler
            }
        }

        const connect = async () => {
            log.rtc('Start')
            try {
                await signal.connect()
            } catch (e) {
                return
            }

            // !to add error handler
            pc = new RTCPeerConnection({iceServers: [{urls: 'stun:stun.l.google.com:19302'}]})

            pc.onconnectionstatechange = _ => log.rtc(`→ ${pc.connectionState}`)
            pc.oniceconnectionstatechange = _ => log.ice(`→ ${pc.iceConnectionState}`)
            pc.onicegatheringstatechange = e => log.ice(`→ ${e.target.iceGatheringState}`)

            let dc = pc.createDataChannel('data')
            dc.onmessage = event => log.rtc(`data chan: ${event.data}`, true)

            pc.onicecandidate = e => {
                if (!e.candidate) return;
                log.ice(`local ${e.candidate.candidate}`)
                if (e.candidate.candidate === "") {
                } else {
                    signal.send({t: "ICE", p: e.candidate})
                }
            }

            signal.wire = (message) => {
                switch (message.t) {
                    case "ANSWER":
                        pc.setRemoteDescription(message.p)
                        log.rtc(`SDP answer: ${message.p.sdp}`, true)
                        return
                    case "ICE":
                        pc.addIceCandidate(message.p)
                        log.ice(`remote ${message.p.candidate}`, true)
                        return
                    case "LOG":
                        gui.log(message.p.text, true, message.p.tag)
                        return
                }
            }

            pc.createOffer().then(offer => {
                pc.setLocalDescription(offer)
                signal.send({t: "OFFER", p: offer});
                log.rtc(`SDP offer: ${offer.sdp}`)
            })
        }
        const disconnect = async () => {
            if (!pc) return
            pc.close()
            await signal.disconnect()
            log.rtc('Stop')
        }
        return {
            connect,
            disconnect,
        }
    })();

    (() => {
        const server = webrtc({transport: socket({url: `ws://${window.location.host}/websocket`})});

        (() => {
            const control = document.getElementById('controls__button');
            let active = false;
            control.addEventListener('click', async () => {
                active = !active
                if (active) {
                    control.textContent = 'Stop'
                    await server.connect()
                } else {
                    control.textContent = 'Start'
                    await server.disconnect()
                    gui.log()
                }
            })
        })()
    })()
</script>
</html>
