<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>WebRTC Testing & Troubleshooting Tool</title>
    <link rel="icon" href="data:,">
    <style>
        h4 {
            padding: 0;
            margin: 0;
        }

        .container {
            display: flex;
            flex-direction: column;

            margin-left: auto;
            margin-right: auto;
            max-width: 64rem;

            gap: 20px;
        }

        @keyframes append-animate {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        .log {
            align-items: center;
            display: grid;
            grid-template-columns: 2.1fr .7fr 1fr 30fr;
            animation: append-animate .3s linear;
        }

        .log div {
            font-size: smaller;
        }

        .log__status, .log__tag, .log__time, .log__dir {
            align-self: normal;
        }

        .log__status {
            background-color: rgb(66, 153, 225);

            border-radius: 9999px;

            height: 8px;
            width: 8px;
        }

        .log__tag {
            text-transform: uppercase;
        }

        .log__tag, .log__dir {
            font-family: monospace;
            font-size: initial !important;
            color: #4299e1;
        }

        .log__client .log__tag {
            color: #e18a42;
        }

        .log__client .log__dir {
            color: white;
        }

        .log__content {
            flex: 1;
        }

        .log.break {
            margin: 0.3em 0;
        }

        .log__time {
        }

        .grayed {
            color: rgba(0, 0, 0, .4);
        }

        .options {
            align-items: center;
            display: flex;

            justify-content: space-between;
            border-bottom: 1px solid rgba(0, 0, 0, 0.3);

            margin: 0;
            padding: 8px 0;
        }

        .options dd {
            margin: 0;
        }

        .opts__main {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            column-gap: 10px;
        }

        .connection__pair {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .controls {
            display: flex;
            position: sticky;
            top: 0;
            background: white;
            padding: 1rem;
            align-items: center;
            justify-content: center;

            z-index: 1;
        }

        button {
            color: #0051c3;
            font-size: 13px;
            border-color: #0045a6;
            transition-timing-function: ease;
            transition-duration: .2s;
            transition-property: background-color, border-color, color;

            padding: 0.5rem 1rem;

            cursor: pointer;

            border-width: 1px;
            border-style: solid;
            border-radius: 0.25rem;

            --bg-opacity: 1;
            background-color: #fff;
            background-color: rgba(255, 255, 255, var(--bg-opacity));
        }

        button.small {
            font-size: 10px;

            padding: .2rem .5rem;
            border: none;
            background: aliceblue;
        }

        button.toggle.active {
            color: white;
            background: #0045a6;
        }

        .logging {
            margin-top: 20px;
        }

        .logging__header, .opts__header {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logging__header__controls, .opts__header__controls {
            display: flex;
            gap: 6px;
        }

        .notice {
            position: relative;
        }

        .notice:before {
            position: absolute;
            background-color: #4299e124;
            content: '';
            left: -12px;
            border-radius: 12px;
            width: 6px;
            height: 6px;
        }

        .opts__header, .logging__header {
            margin-bottom: .33em;
        }
    </style>
</head>
<body>
<div class="container">
    <header>WebRTC Testing & Troubleshooting Tool</header>
    <div id="connection"></div>
    <div class="controls">
        <button id="controls__button">Start</button>
    </div>
    <div class="opts">
        <div class="opts__header">
            <h4>Options</h4>
            <div class="opts__header__controls">
                <button id="opts_reset" class="small" disabled>Reset</button>
            </div>
        </div>
        <div class="opts__main">
            <dl class="options">
                <dt>Flip the offer and the answer sides</dt>
                <dd><input id="opt_flip_offer" type="checkbox"/></dd>
            </dl>
            <dl class="options">
                <dt>Disable default Interceptors</dt>
                <dd><input type="checkbox"/></dd>
            </dl>
            <dl class="options">
                <dt>Use ICE Lite</dt>
                <dd><input type="checkbox"/></dd>
            </dl>
            <dl class="options">
                <dt>Set a single port</dt>
                <dd><input type="number" min="1" max="65535"/></dd>
            </dl>
            <dl class="options">
                <dt>Set NAT-IP-MAP</dt>
                <dd><input type="text"/></dd>
            </dl>
        </div>
    </div>
    <div class="logging">
        <div class="logging__header">
            <h4>Log</h4>
            <div class="logging__header__controls">
                <button id="log_save" class="small">Save</button>
                <button id="log_hide_ip" class="toggle small">Hide public IP</button>
                <button id="log_clear" class="small">Clear</button>
            </div>
        </div>
        <div>
            <div class="log cap">
                <div>time</div>
                <div>dir</div>
                <div>tag</div>
                <div>message</div>
            </div>
            <div id="logMessages"></div>
        </div>
    </div>
</div>
</body>
<script>
    const api = (wire) => ({
        send: {
            webrtc: {
                answer: (answer) => wire.send({t: "ANSWER", p: answer}),
                ice: (candidate) => wire.send({t: "ICE", p: candidate}),
                offer: (offer) => wire.send({t: "OFFER", p: offer}),
                wait_offer: () => wire.send({t: "WAITING_OFFER"}),
            }
        },
        terminate: () => wire.send({t: "CLOSE"})
    })

    const options = {
        log: {
            show_public_ip: true
        },
        webrtc: {
            ice_servers: [
                'stun:stun.l.google.com:19302'
            ],
            flip_offer_side: false
        },
    }

    // time-time
    let startTime, connectTime;

    const gui = (() => {
        const toggles = [...document.getElementsByClassName('toggle')]

        toggles.forEach(e => {
            e.addEventListener('click', () => e.classList.toggle('active'))
        })

        // opts

        // log
        const hideIpOption = document.getElementById('log_hide_ip')
        if (hideIpOption) {
            hideIpOption.addEventListener('click', () => {
                options.log.show_public_ip = !options.log.show_public_ip
            })
        }

        const optFlipOffer = document.getElementById('opt_flip_offer')
        if (optFlipOffer) {
            optFlipOffer.addEventListener('change', _ => {
                options.webrtc.flip_offer_side = optFlipOffer.checked
            })
        }

        const dest = document.getElementById('logMessages')

        const log = (message, server = true, tag, cl) => {
            const el = document.createElement('div')
            el.classList.add('log')
            if (cl) {
                el.classList.add(cl)
            }
            el.classList.add(server ? 'log__server' : 'log__client')
            if (message) {
                let time = formatMs(performance.now() - startTime)
                let i = 0
                while (i < time.length && (time[i] === '0' || time[i] === ':')) {
                    i++;
                }
                if (i) {
                    time = `<span class="grayed">${time.slice(0, i) + "</span>" + time.slice(i)}`
                }

                el.innerHTML = `
                        <div class="log__time">${time}</div>
                        <div class="log__dir">${server ? 's' : 'c'}</div>
                        ${tag ? `<div class="log__tag">${tag}</div>` : ''}
                        <div class="log__content">${message}</div>
                        `
            } else {
                el.classList.add('break')
            }
            dest.appendChild(el)
        }
        return {
            log,
            clear: () => dest.innerHTML = ''
        }
    })()

    const socket = ({url}) => (() => {
        let conn, finish, handlers = [];
        const log = (m) => gui.log(m, false, 'WS');

        const closeCodes = {
            1000: 'Normal Closure', 1001: 'Going Away', 1002: 'Protocol error', 1003: 'Unsupported Data',
            1004: 'Reserved', 1005: 'No Status Rcvd', 1006: 'Abnormal Closure', 1007: 'Invalid frame payload data',
            1008: 'Policy Violation', 1009: 'Message Too Big', 1010: 'Mandatory Ext.', 1011: 'Internal Error',
            1012: 'Service Restart', 1013: 'Try Again Later', 1014: 'Bad Gateway', 1015: 'TLS handshake',
        }

        const connect = (opts) => new Promise(function (resolve, reject) {
            let params;
            if (opts) {
                params = new URLSearchParams(opts).toString()
            }

            const address = `${url}${params ? `?${params}` : ''}`
            log(`connect to ${address}`)

            conn = new WebSocket(address)
            conn.onmessage = e => {
                const msg = JSON.parse(e.data)
                if (!msg) {
                    log('error: failed to parse msg')
                }
                handlers.forEach(h => h(msg))
            }
            conn.onopen = e => {
                log('→ opened')
                resolve(e)
            }
            conn.onclose = e => {
                if (finish) {
                    finish()
                    finish = null
                }
                log(`→ closed: ${e.code} (${closeCodes[e.code]})`)
            }
            conn.onerror = e => {
                log(`→ fail${e.message ? `: ${e.message}` : ''}`)
                reject(e)
            }
        })

        const disconnect = () => new Promise(function (resolve) {
            if (!conn) return;
            finish = resolve
            handlers = []
            conn.close(1000)
            conn = null
        })

        return {
            connect,
            disconnect,
            send: (data) => conn.send(data),
            set onmessage(handler) {
                handlers.push(handler)
            },
        }
    })();

    function formatMs(ms) {
        return `${String(Math.floor((ms / (1000 * 60)) % 60)).padStart(2, '0')}:` +
            `${String(Math.floor((ms / 1000) % 60)).padStart(2, '0')}.` +
            `${String(Math.floor(ms % 1000)).padStart(3, '0')}`;
    }

    const webrtc = ({_api, transport}) => (() => {
        let pc
        const log = {
            ice: (m, remote = false) => gui.log(m, remote, 'ICE'),
            rtc: (m, remote = false, cl) => gui.log(m, remote, 'RTC', cl),
        }

        const signal = {
            send: (dat) => transport.send(JSON.stringify(dat)),
            connect: async (opts) => transport.connect(opts),
            disconnect: async _ => transport.disconnect(),
            set wire(handler) {
                transport.onmessage = handler
            }
        }

        const api = _api(signal)

        const connect = async ({flip_offer_side = false}) => {
            connectTime = performance.now();
            startTime = performance.now();
            log.rtc('Start')
            try {
                await signal.connect({flip_offer_side: flip_offer_side})
            } catch (e) {
                return
            }

            // !to add error handler
            pc = new RTCPeerConnection({
                iceServers: options.webrtc.ice_servers.map(s => ({urls: s}))
            })

            pc.onconnectionstatechange = async _ => {
                log.rtc(`→ ${pc.connectionState}`)
                if (pc.connectionState === 'connected') {

                    const elapsed = `${Math.floor(performance.now() - connectTime)} ms`

                    let local, localId, remote, remoteId;
                    let stats = await pc.getStats();
                    for (const value of stats.values()) {
                        if (value.type === 'candidate-pair') {
                            if (value.state === 'succeeded') {
                                remoteId = value.remoteCandidateId
                                localId = value.localCandidateId
                                continue
                            }
                        }
                        if (value.type === "local-candidate" || value.type === "remote-candidate")
                            if (value.id === localId) {
                                local = value
                            }
                        if (value.id === remoteId) {
                            remote = value
                        }
                    }
                    const dest = document.getElementById('connection')
                    const frag = document.createDocumentFragment()
                    const text = document.createElement('div')
                    text.classList.add('connection__pair')
                    const pair = `[${local.candidateType}] ${local.protocol}://${local.address ? local.address : ''}:${local.port}` +
                        ` --- [${remote.candidateType}] ${remote.protocol}://${remote.address}:${remote.port} (${elapsed})`
                    text.innerText = pair
                    log.rtc(`done / ${pair}`, false, 'notice')
                    frag.append(text)
                    dest.append(frag)
                }
            }
            pc.oniceconnectionstatechange = _ => log.ice(`→ ${pc.iceConnectionState}`)
            pc.onicegatheringstatechange = e => log.ice(`→ ${e.target.iceGatheringState}`)
            pc.onsignalingstatechange = _ => gui.log(`→ ${pc.signalingState}`, false, 'sig')

            if (options.webrtc.flip_offer_side) {
                pc.ondatachannel = e => {
                    const ch = e.channel
                    ch.onmessage = e => {
                        log.rtc(e.data.replaceAll('1', String.fromCharCode(9679)).replaceAll('0', String.fromCharCode(9675)), true)
                    }
                    // ch.onopen = myHandleOpen;
                    // ch.onclose = myHandleClose;
                }
            } else {
                let dc = pc.createDataChannel('data');

                dc.onmessage = e => {
                    log.rtc(e.data.replaceAll('1', String.fromCharCode(9679)).replaceAll('0', String.fromCharCode(9675)), true)
                }
            }

            pc.onicecandidate = e => {
                if (!e.candidate) return;

                let addr = e.candidate.address;
                let cdd = e.candidate.candidate;

                if (!options.log.show_public_ip) {
                    if (!/(0\.0\.0\.0)|(10\..*\..*\..*)|(172\.(1[6-9]|2[0-9]|3[0-1])\..*\..*)|(192\.168\..*\..*)|([a-z0-9.-]+\.local)/.test(addr)) {
                        cdd = cdd.replace(addr, '¯ \\ _ (ツ) _ / ¯')
                    }
                }

                log.ice(`local ${cdd}`)
                if (e.candidate.candidate === "") {
                } else {
                    api.send.webrtc.ice(e.candidate)
                }
            }

            signal.wire = async (message) => {
                switch (message.t) {
                    case "ANSWER":
                        await pc.setRemoteDescription(message.p)
                        log.rtc(`SDP answer: ${message.p.sdp}`, true)
                        return
                    case "ICE":
                        // !to handle TypeError
                        // https://stackoverflow.com/questions/58908081/webrtc-getting-failed-to-execute-addicecandidate-on-rtcpeerconnection-error-on
                        pc.addIceCandidate(message.p).catch(e => {
                            console.log(message, "Failure during addIceCandidate(): " + e.name);
                        });
                        log.ice(`remote ${message.p.candidate}`, true)
                        return
                    case "LOG":
                        gui.log(message.p.text, true, message.p.tag)
                        return
                    case "OFFER":
                        log.rtc(`SDP offer: ${message.p.sdp}`, true)
                        await pc.setRemoteDescription(message.p)
                        const answer = await pc.createAnswer()
                        api.send.webrtc.answer(answer)
                        log.rtc(`SDP answer: ${answer.sdp}`)
                        await pc.setLocalDescription(answer)
                        return
                }
            }

            if (options.webrtc.flip_offer_side) {
                api.send.webrtc.wait_offer()
            } else {
                pc.createOffer().then(offer => {
                    pc.setLocalDescription(offer)
                    api.send.webrtc.offer(offer)
                    log.rtc(`SDP offer: ${offer.sdp}`)
                })
            }
        }
        const disconnect = async () => {
            // api.terminate()
            if (!pc) return
            pc.close()
            await signal.disconnect()
            log.rtc('Stop')
        }
        return {
            connect,
            disconnect,
        }
    })();

    (() => {
        const server = webrtc({_api: api, transport: socket({url: `ws://${window.location.host}/websocket`})});

        const downloadToFile = (content, filename, contentType) => {
            const file = new Blob([content], {type: contentType});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(file);
            a.download = filename;
            a.click();
            URL.revokeObjectURL(a.href);
        };

        const control = document.getElementById('controls__button');
        let active = false;
        control.addEventListener('click', async () => {
            active = !active
            if (active) {
                control.textContent = 'Stop'
                await server.connect({
                    flip_offer_side: options.webrtc.flip_offer_side,
                })
            } else {
                control.textContent = 'Start'
                await server.disconnect()
                gui.log()
            }
        })
        const logClear = document.getElementById('log_clear');
        logClear.addEventListener('click', () => {
            gui.clear()
        })
        const logSave = document.getElementById('log_save');
        logSave.addEventListener('click', () => {
            const txt = document.getElementById('logMessages');

            let text = '';
            let children = txt.children;
            for(let i=0; i<children.length; i++){
                let row = children[i];
                let children_ = row.children;
                let line = '';
                for(let j=0; j<children_.length; j++){
                    let field = children_[j];
                    line += field.innerText;
                    line += ' '
                }
                text += line
                text += '\r\n';
            }

            downloadToFile(text, 'my-new-file.txt', 'text/plain');
        })
    })()
</script>
</html>
