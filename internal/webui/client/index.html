<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>WebRTC Testing & Troubleshooting Tool</title>
    <link rel="icon" href="data:,">
    <style>
        .container {
            display: flex;
            flex-direction: column;

            margin-left: auto;
            margin-right: auto;
            max-width: 64rem;
        }

        .container__main {
            flex-grow: 1;

            display: flex;
            flex-direction: row;
        }

        .container__left {
            width: 25%;
        }

        .container__middle {
            flex-grow: 1;
            display: flex;
            align-items: center;
            flex-direction: column;
            /*justify-content: center;*/
        }

        .container__right {
            width: 20%;
        }

        .cards {
            display: flex;

            flex-wrap: wrap;

            margin-left: -8px;
            margin-right: -8px;
        }

        .cards__item {
            flex-basis: 25%;

            padding-left: 8px;
            padding-right: 8px;
        }

        @keyframes append-animate {
            from {
                /*transform: scale(0);*/
                opacity: 0;
            }
            to {
                /*transform: scale(1);*/
                opacity: 1;
            }
        }

        .log {
            align-items: center;
            display: grid;
            grid-template-columns: 15px 1fr 28fr;
            animation: append-animate .3s linear;
        }

        .log div {
            font-size: smaller;
        }

        .log__status, .log__tag {
            align-self: normal;
        }

        .log__status {
            background-color: rgb(66, 153, 225);

            border-radius: 9999px;

            height: 8px;
            width: 8px;
        }

        .log__tag {
            color: rgba(0, 0, 0, .45);
            text-transform: uppercase;
        }

        .log__client {
            background-color: #e18a42;
        }

        .log__content {
            flex: 1;
        }

        .log.break {
            margin: 0.3em 0;
        }

        .options {
            align-items: center;
            display: flex;

            justify-content: space-between;
            border-bottom: 1px solid rgba(0, 0, 0, 0.3);

            margin: 0;
            padding: 8px 0;
        }

        .options dd {
            margin: 0;
        }

        div#inboundDataChannelMessages, div#iceConnectionStates {
            height: 100px;
            overflow: auto;
            font-size: 80%;
        }

        .connection__pair {
            display: flex;
            flex: 10;
            align-items: center;
        }

        .controls {
            display: flex;
            position: sticky;
            top: 0;
            background: white;
            padding: 1rem;
            align-items: center;
            justify-content: center;
        }

        .maze, .maze-odd {
            position: relative;
            height: 16px;
        }

        button {
            color: #0051c3;
            font-size: 13px;
            border-color: #0045a6;
            -webkit-transition-timing-function: ease;
            transition-timing-function: ease;
            -webkit-transition-duration: .2s;
            transition-duration: .2s;
            -webkit-transition-property: background-color, border-color, color;
            transition-property: background-color, border-color, color;

            padding: 0.5rem 1rem;

            cursor: pointer;

            border-width: 1px;
            border-style: solid;
            border-radius: 0.25rem;

            --bg-opacity: 1;
            background-color: #fff;
            background-color: rgba(255, 255, 255, var(--bg-opacity));
        }

        button.small {
            font-size: 10px;

            padding: .2rem .5rem;
            border: none;
            background: aliceblue;
        }

        .logging__header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
    </style>
</head>
<body>
<div class="container">
    <header>
        WebRTC Testing & Troubleshooting Tool
    </header>
    <main class="container__main">
        <div class="container__left">...</div>

        <div class="container__middle">
            <div id="connection"></div>

        </div>

        <div class="container__right">
            <h4>Options </h4>
            <dl class="options">
                <dt>Flip the offer and the answer sides</dt>
                <dd><input type="checkbox"/></dd>
            </dl>
            <dl class="options">
                <dt>Disable default Interceptors</dt>
                <dd><input type="checkbox"/></dd>
            </dl>
            <dl class="options">
                <dt>Set DTLS role</dt>
                <dd><label>
                    <input type="text"/>
                </label></dd>
            </dl>
            <dl class="options">
                <dt>Use ICE Lite</dt>
                <dd><input type="checkbox"/></dd>
            </dl>
            <dl class="options">
                <dt>Set a single port</dt>
                <dd><input type="text"/></dd>
            </dl>
            <dl class="options">
                <dt>Set NAT-IP-MAP</dt>
                <dd><input type="text"/></dd>
            </dl>
        </div>
    </main>
    <footer>
        <div class="controls">
            <button id="controls__button">Start</button>
        </div>
        <div class="logging">
            <div class="logging__header">
                <h3>Log</h3>
                <button id="log_clear" class="small">X</button>
            </div>
            <div id="logMessages"></div>
        </div>
    </footer>
</div>
</body>
<script>
    const gui = (() => {
        const dest = document.getElementById('logMessages')

        const log = (message, server = true, tag, contentCl) => {
            const el = document.createElement('div')
            el.classList.add('log')
            if (message) {
                el.innerHTML = `
                        <div class="log__status${server ? ' log__server' : ' log__client'}"></div>
                        ${tag ? `<div class="log__tag">${tag}</div>` : ''}
                        <div class="log__content${contentCl ? ` ${contentCl}` : ''}">${message}</div>
                        `
            } else {
                el.classList.add('break')
            }
            dest.appendChild(el)
        }

        return {
            log,
            clear: () => {
                dest.innerHTML = ''
            }
        }
    })()

    const socket = ({url}) => (() => {
        let _socket, finish, handlers = [];
        const log = (m) => gui.log(m, false, 'WS');

        const closeCodes = {
            1000: 'Normal Closure', 1001: 'Going Away', 1002: 'Protocol error', 1003: 'Unsupported Data',
            1004: 'Reserved', 1005: 'No Status Rcvd', 1006: 'Abnormal Closure', 1007: 'Invalid frame payload data',
            1008: 'Policy Violation', 1009: 'Message Too Big', 1010: 'Mandatory Ext.', 1011: 'Internal Error',
            1012: 'Service Restart', 1013: 'Try Again Later', 1014: 'Bad Gateway', 1015: 'TLS handshake',
        }

        const connect = () => new Promise(function (resolve, reject) {
            log(`connect to ${url}`)
            _socket = new WebSocket(url)
            _socket.onmessage = e => {
                const msg = JSON.parse(e.data)
                if (!msg) {
                    log('error: failed to parse msg')
                }
                handlers.forEach(h => h(msg))
            }
            _socket.onopen = e => {
                log('→ opened')
                resolve(e)
            }
            _socket.onclose = e => {
                if (finish) {
                    finish()
                    finish = null
                }
                log(`→ closed: ${e.code} (${closeCodes[e.code]})`)
            }
            _socket.onerror = e => {
                log(`→ fail${e.message ? `: ${e.message}` : ''}`)
                reject(e)
            }
        })

        const disconnect = () => new Promise(function (resolve) {
            if (!_socket) return;
            finish = resolve
            handlers = []
            _socket.close(1000)
            _socket = null
        })

        return {
            connect,
            disconnect,
            send: (data) => _socket.send(data),
            set onmessage(handler) {
                handlers.push(handler)
            },
        }
    })();

    const webrtc = ({transport}) => (() => {
        let pc
        const log = {
            ice: (m, remote = false) => gui.log(m, remote, 'ICE'),
            rtc: (m, remote = false, cl) => gui.log(m, remote, 'RTC', cl),
        }

        const signal = {
            send: (dat) => transport.send(JSON.stringify(dat)),
            connect: async _ => transport.connect(),
            disconnect: async _ => transport.disconnect(),
            set wire(handler) {
                transport.onmessage = handler
            }
        }

        const connect = async () => {
            log.rtc('Start')
            try {
                await signal.connect()
            } catch (e) {
                return
            }

            // !to add error handler
            pc = new RTCPeerConnection({iceServers: [{urls: 'stun:stun.l.google.com:19302'}]})

            pc.onconnectionstatechange = async _ => {
                log.rtc(`→ ${pc.connectionState}`)
                if (pc.connectionState === 'connected') {
                    let local, localId, remote, remoteId;
                    let stats = await pc.getStats();
                    for (const value of stats.values()) {
                        if (value.type === 'candidate-pair') {
                            if (value.state === 'succeeded') {
                                remoteId = value.remoteCandidateId
                                localId = value.localCandidateId
                                continue
                            }
                        }
                        if (value.type === "local-candidate" || value.type === "remote-candidate")
                            if (value.id === localId) {
                                local = value
                            }
                        if (value.id === remoteId) {
                            remote = value
                        }
                    }
                    const dest = document.getElementById('connection')
                    const frag = document.createDocumentFragment()
                    const text = document.createElement('div')
                    text.classList.add('connection__pair')
                    const pair = `[${local.candidateType}] ${local.protocol}://${local.address ? local.address : ''}:${local.port}` +
                        ` --- [${remote.candidateType}] ${remote.protocol}://${remote.address}:${remote.port}`
                    text.innerText = pair
                    log.rtc(`pair [${pair}]`)
                    frag.append(text)
                    dest.append(frag)
                }
            }
            pc.oniceconnectionstatechange = _ => log.ice(`→ ${pc.iceConnectionState}`)
            pc.onicegatheringstatechange = e => log.ice(`→ ${e.target.iceGatheringState}`)
            pc.onsignalingstatechange = _ => gui.log(`→ ${pc.signalingState}`, false, 'sig')

            let dc = pc.createDataChannel('data');

            dc.onmessage = e => {
                log.rtc(e.data.replaceAll('1', String.fromCharCode(9679)).replaceAll('0', String.fromCharCode(9675)))
            }

            pc.onicecandidate = e => {
                if (!e.candidate) return;

                let addr = e.candidate.address;
                let cdd = e.candidate.candidate;

                if (!/(0\.0\.0\.0)|(10\..*\..*\..*)|(172\.(1[6-9]|2[0-9]|3[0-1])\..*\..*)|(192\.168\..*\..*)|([a-z0-9.-]+\.local)/.test(addr)) {
                    cdd = cdd.replace(addr, '¯ \\ _ (ツ) _ / ¯')
                    // cdd = cdd.replace(addr, addr.replaceAll(/[0-9]/g, String.fromCharCode(9633)))
                }

                log.ice(`local ${cdd}`)
                if (e.candidate.candidate === "") {
                } else {
                    signal.send({t: "ICE", p: e.candidate})
                }
            }

            signal.wire = (message) => {
                switch (message.t) {
                    case "ANSWER":
                        pc.setRemoteDescription(message.p)
                        log.rtc(`SDP answer: ${message.p.sdp}`, true)
                        return
                    case "ICE":
                        // !to handle TypeError
                        // https://stackoverflow.com/questions/58908081/webrtc-getting-failed-to-execute-addicecandidate-on-rtcpeerconnection-error-on
                        pc.addIceCandidate(message.p)
                        log.ice(`remote ${message.p.candidate}`, true)
                        return
                    case "LOG":
                        gui.log(message.p.text, true, message.p.tag)
                        return
                }
            }

            pc.createOffer().then(offer => {
                pc.setLocalDescription(offer)
                signal.send({t: "OFFER", p: offer});
                log.rtc(`SDP offer: ${offer.sdp}`)
            })
        }
        const disconnect = async () => {
            if (!pc) return
            pc.close()
            await signal.disconnect()
            log.rtc('Stop')
        }
        return {
            connect,
            disconnect,
        }
    })
    ();

    (() => {
        const server = webrtc({transport: socket({url: `ws://${window.location.host}/websocket`})});

        (() => {
            const control = document.getElementById('controls__button');
            let active = false;
            control.addEventListener('click', async () => {
                active = !active
                if (active) {
                    control.textContent = 'Stop'
                    await server.connect()
                } else {
                    control.textContent = 'Start'
                    await server.disconnect()
                    gui.log()
                }
            })
            const logClear = document.getElementById('log_clear');
            logClear.addEventListener('click', () => {
                gui.clear()
            })
        })()
    })()
</script>
</html>
